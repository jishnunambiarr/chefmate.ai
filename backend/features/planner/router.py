from fastapi import APIRouter, Depends, HTTPException, Body
from typing import Dict, Any, List
from features.auth.firebase import get_current_user
from features.planner.models import WeeklyPlan, WeeklyPlanCreate, DayPlan, MealItem
from google.cloud import firestore
from datetime import datetime
import logging

# Initialize Firestore connection
from features.database.firestore import db

router = APIRouter(prefix="/planner", tags=["Planner"])
logger = logging.getLogger(__name__)

PLANS_COLLECTION = "meal_plans"

@router.get("", response_model=WeeklyPlan)
async def get_current_plan(user: dict = Depends(get_current_user)):
    """Get the latest weekly plan for the user."""
    user_id = user["uid"]
    
    # Query for the most recent plan
    docs = (
        db.collection(PLANS_COLLECTION)
        .where("userId", "==", user_id)
        .order_by("createdAt", direction=firestore.Query.DESCENDING)
        .limit(1)
        .stream()
    )
    
    plan_data = None
    for doc in docs:
        plan_data = doc.to_dict()
        # id is not usually in to_dict() unless explicitly put there
        # but our model might expect it. for now let's just trust the data structure matches
        break
    
    if not plan_data:
        # Return empty default plan structure if nothing found
        default_days = [
            DayPlan(day=d, breakfast=[], lunch=[], dinner=[])
            for d in ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
        ]
        return WeeklyPlan(days=default_days, user_id=user_id, created_at=datetime.now())
        
    # Map Firestore camelCase to Pydantic snake_case
    if "userId" in plan_data:
        plan_data["user_id"] = plan_data.pop("userId")
    if "createdAt" in plan_data:
        plan_data["created_at"] = plan_data.pop("createdAt")
        
    return plan_data

@router.post("", response_model=WeeklyPlan)
async def save_weekly_plan(
    plan_data: Dict[str, Any],
    user: dict = Depends(get_current_user)
):
    """
    Save a weekly plan generated by the agent.
    Accepts loose JSON structure (e.g. dict with days as keys) and converts to strict model.
    """
    user_id = user["uid"]
    logger.info(f"Received plan create request for user {user_id}")
    user_id = user["uid"]
    logger.info(f"Received plan create request for user {user_id}")

    
    # Handle the case where the plan is wrapped in a "planJson" key (from frontend or agent)
    if "planJson" in plan_data:
        import json
        try:
            potential_json = plan_data["planJson"]
            if isinstance(potential_json, str):
                plan_data = json.loads(potential_json)
            elif isinstance(potential_json, dict):
                plan_data = potential_json
            logger.info(f"Parsed planJson: {plan_data}")
        except Exception as e:
            logger.error(f"Failed to parse planJson: {e}")
            # Continue with original data if parsing fails, might still work


    # Helper to convert various inputs (string, list of strings, list of objects) into List[MealItem]
    def process_meals(meal_input) -> List[MealItem]:
        if isinstance(meal_input, str):
             # Split by comma if it's a combined string like "Eggs, Toast"
             items = [x.strip() for x in meal_input.split(',')]
             return [MealItem(name=item, emoji="üçΩÔ∏è") for item in items if item]
        elif isinstance(meal_input, list):
            # Could be list of strings or list of objects
            result = []
            for item in meal_input:
                if isinstance(item, str):
                    result.append(MealItem(name=item, emoji="üçΩÔ∏è"))
                elif isinstance(item, dict):
                    # If agent sends objects, try to find name/emoji
                    name = item.get("name") or item.get("title") or "Unknown"
                    emoji = item.get("emoji") or "üçΩÔ∏è"
                    result.append(MealItem(name=name, emoji=emoji))
            return result
        return []

    # Logic to normalize the input JSON into our DayPlan list
    days_list = []
    week_days_order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    
    # 1. Check if input is ALREADY in the shape of { "days": [...] }
    if "days" in plan_data and isinstance(plan_data["days"], list):
        # Allow Pydantic to validate it directly later, or process if needed.
        # Ideally we trust the structure if it matches, but let's be robust.
        # For simplicity, let's treat the root dict as the source of truth if keys match day names.
        pass

    # 2. Heuristic: Check if keys are day names (e.g. { "monday": {...}, "tuesday": ... })
    # Normalize keys to lowercase for checking
    plan_data_lower = {k.lower(): v for k, v in plan_data.items()}
    
    for day_name in week_days_order:
        day_key = day_name.lower()
        day_content = plan_data_lower.get(day_key, {})
        
        # Handle simplified format where day value is just a string (e.g. "Monday": "Pasta")
        if isinstance(day_content, str):
            # Treat the string as the main meal (dinner)
            breakfast = []
            lunch = []
            dinner = process_meals(day_content)
        else:
            # Standard object format
            breakfast = process_meals(day_content.get("breakfast", []))
            lunch = process_meals(day_content.get("lunch", []))
            dinner = process_meals(day_content.get("dinner", []))
        
        days_list.append(DayPlan(
            day=day_name,
            breakfast=breakfast,
            lunch=lunch,
            dinner=dinner
        ))

    # Create the Plan object
    new_plan = WeeklyPlan(
        days=days_list,
        user_id=user_id,
        created_at=datetime.now()
    )
    
    # Dump to dict for Firestore
    doc_data = new_plan.model_dump()
    
    # Convert to camelCase for Firestore (to match index)
    doc_data['userId'] = doc_data.pop('user_id')
    doc_data['createdAt'] = firestore.SERVER_TIMESTAMP 
    if 'created_at' in doc_data:
        del doc_data['created_at']

    # Save to Firestore
    _, doc_ref = db.collection(PLANS_COLLECTION).add(doc_data)
    
    # Return response (keep snake_case for Pydantic response model)
    response_model = new_plan.model_copy()
    # Ideally fetch the real ID? or just return what we have
    # response_model.id = doc_ref.id # WeeklyPlan model doesn't have an ID field yet, skipping
    return response_model
